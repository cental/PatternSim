#! /usr/bin/env perl
#======================================================================
#    NAME: patternsim
#======================================================================
#  AUTHOR: Hubert Naets <hubert.naets@uclouvain.be>
#======================================================================
# USAGE: perl ./pattersim
#======================================================================
use strict;
use warnings;
use utf8;

our $VERSION = '0.3';

use Getopt::Long;
use Config::General;
use Pod::Usage;
use File::HomeDir;
use File::Temp;
use Parallel::ForkManager;
use IPC::Run3;
use File::Spec::Functions qw(rel2abs);
use File::Basename qw(dirname);
use Encode;
use Data::Dumper;



# Log facility
use Log::Message::Simple qw[msg error debug carp croak cluck confess];
local $Log::Message::Simple::MSG_FH     = \*STDERR;
local $Log::Message::Simple::ERROR_FH   = \*STDERR;
local $Log::Message::Simple::DEBUG_FH   = \*STDERR;

use Lingua::Unitex;

# Default log values
my $verbose = 0;
my $debug   = 0;
my $error   = 1;

#----------------------------------------------------------------------
# OS detection
# (useful to known the unitex exe to use)
#----------------------------------------------------------------------
my %os = (
    MacOS   => 'Unix',
    MSWin32 => 'Win',
);
my $os = $os{$^O} || 'Unix';

#----------------------------------------------------------------------
# Script directory
#----------------------------------------------------------------------
my $script_path = rel2abs($0);
my $script_dir  = dirname($script_path) . '/';

#----------------------------------------------------------------------
# args
#----------------------------------------------------------------------
my $opts   = {};
my $result = GetOptions(
    'vocabulary|vocab|v=s'  => \$opts->{vocabulary},
    'output-dir|output|o=s' => \$opts->{output_dir},
    'unitex=s'              => \$opts->{unitex_dir},
    'language|l:s'          => \$opts->{language},
    'workers|w:i'           => \$opts->{workers_nb},
    'debug'                 => \$opts->{debug},
    'verbose|v'             => \$opts->{verbose},
    'help|h'                => \$opts->{help},
    'man'                   => \$opts->{man},
);

$opts->{corpora} = [@ARGV];

if ( $opts->{debug} ) {
  msg("debug mode activated",1);
  $debug   = 1;
  $verbose = 1;
}
if ( $opts->{verbose} ) {
  msg("verbose mode activated",1);
  $verbose = 1;
}

debug( "Program arguments are:\n" . Dumper($opts), $debug );

#----------------------------------------------------------------------
# help or man page
#----------------------------------------------------------------------
pod2usage(2) if ( $opts->{help} );
pod2usage(1) if ( $opts->{man} );
if ( not $opts->{vocabulary} or not $opts->{output_dir} ) {
    print "\nMissing argument\n";
    pod2usage(2);
}

#----------------------------------------------------------------------
# args validation
#----------------------------------------------------------------------
exit(1) if not _are_valid_opts($opts);

#----------------------------------------------------------------------
# unitex validation
#----------------------------------------------------------------------
exit(2)
  if defined $opts->{unitex_dir}
      and not _is_valid_unitex_installation( $opts->{unitex_dir} );

#----------------------------------------------------------------------
# first usage: config file
# the config file must include unitex dir
#----------------------------------------------------------------------
my $data_dir       = File::HomeDir->my_data;           # determine data user dir
my $patternsim_dir = $data_dir . '/' . 'patternsim';
if ( not -e $patternsim_dir ) {
    mkdir $patternsim_dir;
    debug( "Directory '$patternsim_dir' created", $debug );
    msg( "Directory '$patternsim_dir' created", $verbose );
}

my $patternsimrc = "$patternsim_dir/patternsimrc";
if ( not -e $patternsimrc ) {

    my $config_data = {
        'unitex'           => { unitex_dir => undef, user_dir => undef },
        'parallel_manager' => {
          'workers_nb'            => 2,
          'temp_dir'              => "$patternsim_dir/parallel_temp",
          'workers_time_to_live'  => 600, # worker will be killed after this time (in seconds)
        },
        'corpora'          => {
            'split_at_size' => 100_000, # in characters
            'temp_dir'      => "$patternsim_dir/corpus_temp",
        },
        languages          => {
            'en' => {
                'unitex_language_name' => 'English',
                'lexical_resources'    => 'share/Resources/English/Dela/*.bin',
                'main_fst2_graph'      => 'share/Resources/English/Graphs/hypernymy/hypernym_main.fst2',
            },
            'ru' => {
                'unitex_language_name' => 'Russian',
                'lexical_resources'    => 'share/Resources/Russian/Dela/*.bin',
                'main_fst2_graph'      => 'share/Resources/Russian/Graphs/hypernymy/hypernym_main.fst2',
   
            },
        },
        default_language => 'en',
        version => $VERSION,
    };

    my $config = Config::General->new($config_data);
    $config->save_file($patternsimrc);

    msg( "File '$patternsimrc' created", $verbose );
}


msg( "Using configuration file '$patternsimrc'", $verbose );

my $config = Config::General->new( $patternsim_dir . '/patternsimrc' );
my %config = $config->getall();

#----------------------------------------------------------------------
# check if configuration file is up to date
#----------------------------------------------------------------------
if (not exists $config{version} or $config{version} ne $VERSION ) {
  my $old_config_file = $config{version} // 'not available';
  error("Your configuration file '$patternsimrc' need to be updated\n(actual version: $old_config_file - expected version : $VERSION)\nPlease, delete the '$patternsimrc' file and restart the program",$error);
  exit(3); 
}

msg("Storing temporary files in '". $config{corpora}->{temp_dir} ."'",$verbose);
msg("Storing workers results in '". $config{parallel_manager}->{temp_dir} ."'",$verbose);



#----------------------------------------------------------------------
# Check and select language
#----------------------------------------------------------------------
if ( not $opts->{language} ) {
  $opts->{language} = $config{default_language};
}

if( not $config{languages}->{ $opts->{language} }) {
  error("Language '" . $opts->{language}  . "' is not a valid language" ,$error);
  exit(4);
}

msg("Language selected: " . $opts->{language}, $verbose);

#----------------------------------------------------------------------
# overwrite number of workers from config
#----------------------------------------------------------------------
if ( not $opts->{workers_nb} ) {
  $opts->{workers_nb} = $config{parallel_manager}->{workers_nb};
}
msg("Number of workers: " . $opts->{workers_nb}, $verbose);



#----------------------------------------------------------------------
# New Unitex instance
#----------------------------------------------------------------------

my $unitex = Lingua::Unitex->new(
    language    => $config{languages}->{ $opts->{language} }->{unitex_language_name},
    unitex_dir  => $opts->{unitex_dir},
    verbose_log => $verbose,
    debug_log   => $debug,
    error_log   => $error,
);

#----------------------------------------------------------------------
# Split corpus files in files of $config{corpora}->{split_at_size} size
# to avoid Unitex RAM overusage
#----------------------------------------------------------------------
my @splited_files = ();

mkdir $config{corpora}->{temp_dir} if not -e $config{corpora}->{temp_dir};

my $pattern = 'corpus_XXXXXXXXXXXXXXXX';
my $suffix  = '_utf16le.txt';

my $size = 0;
my $fh_corpus;
my $filename_corpus;
( $fh_corpus, $filename_corpus ) = File::Temp::tempfile(
    $pattern,
    DIR    => $config{corpora}->{temp_dir},
    SUFFIX => $suffix
);
binmode $fh_corpus, ':encoding(utf16le)';
print $fh_corpus "\x{feff}";

while ( my $line = <> ) {
    my $content = Encode::decode( 'utf8', $line );
    $size += length($line);
    if ( $size > $config{corpora}->{split_at_size} ) {
        push @splited_files, $filename_corpus;
        close $fh_corpus;
        $size = 0;
        ( $fh_corpus, $filename_corpus ) = File::Temp::tempfile(
            $pattern,
            DIR    => $config{corpora}->{temp_dir},
            SUFFIX => $suffix
        );
        binmode $fh_corpus, ':encoding(utf16le)';
        print $fh_corpus "\x{feff}";
        print $fh_corpus $content;
    }
    else {
        print $fh_corpus $content;
    }
}
push @splited_files, $filename_corpus;
close $fh_corpus;

#----------------------------------------------------------------------
# Load vocabulary file
#----------------------------------------------------------------------
my $vocabulary_fh = IO::File->new( $opts->{vocabulary}, 'r' );
binmode $vocabulary_fh, ':encoding(utf8)';
my %vocabulary = map { $_ =~ s/\s+$//; lc($_) => 1 } <$vocabulary_fh>;
$vocabulary_fh->close();

#----------------------------------------------------------------------
# Prepare relations extraction
#----------------------------------------------------------------------
my @concord = ();                             # concordances
my $dico    = Lingua::Unitex::Dela->new();    # corpus dictionary

my $corpus_words_freq = {};                   # word frequencies in the corpus
my $conc_words_freq   = {};                   # word frequencies in the concordances

my $relations    = {};                        # token relations
my $relations_np = {};                        # noun phrases relations

#----------------------------------------------------------------------
# Preprocess Corpus with Unitex Tools
#----------------------------------------------------------------------

my $temp_dir    = $config{'parallel_manager'}->{'temp_dir'};
my $workers_nb  = $opts->{workers_nb};
my $workers_ttl = $config{'parallel_manager'}->{'workers_time_to_live'};


mkdir $config{parallel_manager}->{temp_dir} if not -e $config{parallel_manager}->{temp_dir};

my $pm = Parallel::ForkManager->new( $workers_nb, $temp_dir );

my $nb_files_to_process = @splited_files;
my $nb_files_processed = 0;

our %workers;

sub dismiss_hung_workers {
  while (my ($pid, $started_at) = each %workers) {
    msg( "PID RUN ON WAIT $pid", $verbose);
    if (time() - $started_at > $workers_ttl ) {
      kill TERM => $pid;
      delete $workers{$pid};
      msg( "FORK TIMEOUT: $pid - started at $started_at", $verbose );
    }
  }
}

$pm->run_on_start(sub { my $pid = shift; $workers{$pid} = time(); });
$pm->run_on_finish(    # called BEFORE the first call to start()
    sub {
        my ( $pid, $exit_code, $ident, $exit_signal, $core_dump,
            $data_structure_reference ) = @_;
        delete $workers{$pid};
        $nb_files_processed++;
        msg( '['. localtime . "] Processed: #$nb_files_processed / $nb_files_to_process files", $verbose );
	if (defined($data_structure_reference)) {
          push @concord, @{$data_structure_reference->{concord}};
          $dico->merge_with( $data_structure_reference->{dico});

          foreach my $tok ( keys %{$data_structure_reference->{tokens_by_freq}} ) {
            $corpus_words_freq->{$tok} += $data_structure_reference->{tokens_by_freq}->{$tok};
          }
	}
    }
);

msg( "To process: #$nb_files_to_process files", $verbose );

foreach my $file (@splited_files) {
    $pm->start and next;
    
    my $unicorpus = $unitex->corpus( 'filename' => $file );
    $unicorpus->normalize;
    $unicorpus->apply_graph_in_merge_mode;
    $unicorpus->apply_graph_in_replace_mode;
    $unicorpus->tokenize;
    
    my @lexical_resources = glob( $script_dir . $config{languages}->{ $opts->{language} }->{lexical_resources} );
    
    $unicorpus->apply_lexical_ressources( \@lexical_resources );
    my $res = $unicorpus->apply_graph( $script_dir . $config{languages}->{ $opts->{language} }->{main_fst2_graph} );

     $pm->finish(1) if not defined $res;
     
     my $dico = $unicorpus->get_dictionary();

    #$dico->merge_with( $unicorpus->get_dictionary() );
    my @concord        = $unicorpus->get_last_concord();
    my $tokens_by_freq = $unicorpus->get_tokens_by_frequency();

    $unicorpus->delete_all_files();
    $pm->finish(
        0,
        {
            dico           => $dico,
            tokens_by_freq => $tokens_by_freq,
            concord        => \@concord
        }
    );
}
$pm->wait_all_children;

#----------------------------------------------------------------------
# Create output dir
#----------------------------------------------------------------------
mkdir $opts->{output_dir};    # create output dir

#----------------------------------------------------------------------
# Save concordances
#----------------------------------------------------------------------
my $concord_fh = IO::File->new( $opts->{output_dir} . '/' . 'concord.txt', 'w' );
binmode( $concord_fh, ':encoding(utf8)' );

foreach my $conc (@concord) {

    print $concord_fh $conc, "\n";

    my @concord_relations = ();

    #     print "CONC: $conc\n";

    ( my $rule_nb ) = $conc =~ /\[PATTERN=(\d+)\]/;    # [PATTERN=9]
    my @multiwords_with_tags = $conc =~ /\{.+?=[A-Z]+\}/g;    # {[ biopiraterie]=SYNO}

    foreach my $mutiword_with_tags (@multiwords_with_tags) {

        # relation (hypo, hyper, syno, etc.)
        ( my $relation = $mutiword_with_tags ) =~ s/\{.+?=([A-Z]+)\}/$1/;

        # multiword without tags
        ( my $multiword = $mutiword_with_tags ) =~ s/^\{(.+?)=[A-Z]+\}$/$1/;
        $multiword =~ s/\[|\]//g;
        trim($multiword);

        # simpleword without tags
        ( my $simpleword = $mutiword_with_tags ) =~ s/^\{(.+?)=[A-Z]+\}$/$1/;
        $simpleword =~ s/^.*\[(.+)\].*$/$1/g;
        trim($simpleword);

        # lemmatize simpleword
        my $simpleword_lemma = _lemmatize( $dico, $corpus_words_freq, $simpleword );

        #       print "MULTIWORD W. TAG: ", $mutiword_with_tags, "\n";
        #       print "   RELATION:", $relation, "\n";
        #       print "  MULTIWORD:", $multiword, "\n";
        #	print " SIMPLEWORD:", $simpleword, "\n";
        #	print "      LEMMA:", $simpleword_lemma, "\n";

        push(
            @concord_relations,
            {
                multiword  => $multiword,
                simpleword => $simpleword,
                lemma      => $simpleword_lemma,
                relation   => $relation,
                rule       => $rule_nb
            }
        );
    }

    for ( my $i = 0 ; $i < @concord_relations ; $i++ ) {
        my $concord_relation1 = $concord_relations[$i];
        for ( my $j = $i + 1 ; $j < @concord_relations ; $j++ ) {
            my $concord_relation2 = $concord_relations[$j];

            my %saved_relations = ();    # if the relation was previously saved, do not save them another time.

            # multiwords
            next
              if not defined $concord_relation1->{multiword}
              or not defined $concord_relation2->{multiword}
              or $concord_relation1->{multiword} eq ""
              or $concord_relation2->{multiword} eq ""
              or $concord_relation1->{multiword} eq $concord_relation2->{multiword};

            $saved_relations{ $concord_relation1->{multiword} . "\t" . $concord_relation2->{multiword} } = 1;
            $saved_relations{ $concord_relation2->{multiword} . "\t" . $concord_relation1->{multiword} } = 1;

            $relations->{ $concord_relation1->{multiword} }->{ $concord_relation2->{multiword} }->{rules}->{ $concord_relation1->{rule} }++;
            $relations->{ $concord_relation2->{multiword} }->{ $concord_relation1->{multiword} }->{rules}->{ $concord_relation1->{rule} }++;

            if ( $concord_relation1->{relation} eq "HYPO" and $concord_relation2->{relation} eq "HYPER" ) {
                $relations->{ $concord_relation1->{multiword} }->{ $concord_relation2->{multiword} }->{types}->{'hypo'}++;
                $relations->{ $concord_relation1->{multiword} }->{ $concord_relation2->{multiword} }->{types}->{'hyper_hypo'}++;
                $relations->{ $concord_relation2->{multiword} }->{ $concord_relation1->{multiword} }->{types}->{'hyper'}++;
                $relations->{ $concord_relation2->{multiword} }->{ $concord_relation1->{multiword} }->{types}->{'hyper_hypo'}++;
            }
            elsif ( $concord_relation1->{relation} eq "HYPER" and $concord_relation2->{relation} eq "HYPO" ) {
                $relations->{ $concord_relation1->{multiword} }->{ $concord_relation2->{multiword} }->{types}->{'hyper'}++;
                $relations->{ $concord_relation1->{multiword} }->{ $concord_relation2->{multiword} }->{types}->{'hyper_hypo'}++;
                $relations->{ $concord_relation2->{multiword} }->{ $concord_relation1->{multiword} }->{types}->{'hypo'}++;
                $relations->{ $concord_relation2->{multiword} }->{ $concord_relation1->{multiword} }->{types}->{'hyper_hypo'}++;
            }

            elsif ( $concord_relation1->{relation} eq "HYPO" and $concord_relation2->{relation} eq "HYPO" ) {
                $relations->{ $concord_relation1->{multiword} }->{ $concord_relation2->{multiword} }->{types}->{'cohypo'}++;
                $relations->{ $concord_relation2->{multiword} }->{ $concord_relation1->{multiword} }->{types}->{'cohypo'}++;
            }
            elsif ( $concord_relation1->{relation} eq "SYNO" and $concord_relation2->{relation} eq "SYNO" ) {
                $relations->{ $concord_relation1->{multiword} }->{ $concord_relation2->{multiword} }->{types}->{'syno'}++;
                $relations->{ $concord_relation2->{multiword} }->{ $concord_relation1->{multiword} }->{types}->{'syno'}++;
            }
            else {
                msg("unknown relation type: " . $concord_relation1->{relation} . '(' . $concord_relation1->{multiword} . ')'. '-'. $concord_relation2->{relation} . '(' . $concord_relation2->{multiword} . ')', $error);
            }

            # lemma
            next
              if not defined $concord_relation1->{lemma}
              or not defined $concord_relation2->{lemma}
              or $concord_relation1->{lemma} eq ""
              or $concord_relation2->{lemma} eq ""
              or $concord_relation1->{lemma} eq $concord_relation2->{lemma};

            if ( not exists $saved_relations{ $concord_relation1->{lemma} . "\t" . $concord_relation2->{lemma} } ) {
                $saved_relations{ $concord_relation1->{lemma} . "\t" . $concord_relation2->{lemma} } = 1;

                $relations->{ $concord_relation1->{lemma} }->{ $concord_relation2->{lemma} }->{rules}->{ $concord_relation1->{rule} }++;

                if ( $concord_relation1->{relation} eq "HYPO" and $concord_relation2->{relation} eq "HYPER" ) {
                    $relations->{ $concord_relation1->{lemma} }->{ $concord_relation2->{lemma} }->{types}->{'hypo'}++;
                    $relations->{ $concord_relation1->{lemma} }->{ $concord_relation2->{lemma} }->{types}->{'hyper_hypo'}++;
                }
                elsif ( $concord_relation1->{relation} eq "HYPER" and $concord_relation2->{relation} eq "HYPO" ) {
                    $relations->{ $concord_relation1->{lemma} }->{ $concord_relation2->{lemma} }->{types}->{'hyper'}++;
                    $relations->{ $concord_relation1->{lemma} }->{ $concord_relation2->{lemma} }->{types}->{'hyper_hypo'}++;
                }

                elsif ( $concord_relation1->{relation} eq "HYPO" and $concord_relation2->{relation} eq "HYPO" ) {
                    $relations->{ $concord_relation1->{lemma} }->{ $concord_relation2->{lemma} }->{types}->{'cohypo'}++;
                }
                elsif ( $concord_relation1->{relation} eq "SYNO" and $concord_relation2->{relation} eq "SYNO" ) {
                    $relations->{ $concord_relation1->{lemma} }->{ $concord_relation2->{lemma} }->{types}->{'syno'}++;
                }
                else {
                    msg("unknown relation type: " . $concord_relation1->{relation} . '(' . $concord_relation1->{multiword} . ')' . '-' . $concord_relation2->{relation} . '(' . $concord_relation2->{multiword} . ')', $error);
                }

            }

            if ( not exists $saved_relations{ $concord_relation2->{lemma} . "\t" . $concord_relation1->{lemma} } ) {
                $saved_relations{ $concord_relation2->{lemma} . "\t" . $concord_relation1->{lemma} } = 1;

                $relations->{ $concord_relation2->{lemma} }->{ $concord_relation1->{lemma} }->{rules}->{ $concord_relation1->{rule} }++;

                if ( $concord_relation1->{relation} eq "HYPO" and $concord_relation2->{relation} eq "HYPER" ) {
                    $relations->{ $concord_relation2->{lemma} }->{ $concord_relation1->{lemma} }->{types}->{'hyper'}++;
                    $relations->{ $concord_relation2->{lemma} }->{ $concord_relation1->{lemma} }->{types}->{'hyper_hypo'}++;
                }
                elsif ( $concord_relation1->{relation} eq "HYPER" and $concord_relation2->{relation} eq "HYPO" ) {
                    $relations->{ $concord_relation2->{lemma} }->{ $concord_relation1->{lemma} }->{types}->{'hypo'}++;
                    $relations->{ $concord_relation2->{lemma} }->{ $concord_relation1->{lemma} }->{types}->{'hyper_hypo'}++;
                }

                elsif ( $concord_relation1->{relation} eq "HYPO" and $concord_relation2->{relation} eq "HYPO" ) {
                    $relations->{ $concord_relation2->{lemma} }->{ $concord_relation1->{lemma} }->{types}->{'cohypo'}++;
                }
                elsif ( $concord_relation1->{relation} eq "SYNO" and $concord_relation2->{relation} eq "SYNO" ) {
                    $relations->{ $concord_relation2->{lemma} }->{ $concord_relation1->{lemma} }->{types}->{'syno'}++;
                }
                else {
                    msg("unknown relation type: " . $concord_relation1->{relation} . '(' . $concord_relation1->{multiword} . ')' . '-' . $concord_relation2->{relation} . '(' . $concord_relation2->{multiword} . ')', $error);
                }
            }

            if ( not exists $saved_relations{ $concord_relation1->{lemma} . "\t" . $concord_relation2->{multiword} } ) {
                $saved_relations{ $concord_relation1->{lemma} . "\t" . $concord_relation2->{multiword} } = 1;

                $relations->{ $concord_relation1->{lemma} }->{ $concord_relation2->{multiword} }->{rules}->{ $concord_relation1->{rule} }++;

                if ( $concord_relation1->{relation} eq "HYPO" and $concord_relation2->{relation} eq "HYPER" ) {
                    $relations->{ $concord_relation1->{lemma} }->{ $concord_relation2->{multiword} }->{types}->{'hypo'}++;
                    $relations->{ $concord_relation1->{lemma} }->{ $concord_relation2->{multiword} }->{types}->{'hyper_hypo'}++;
                }
                elsif ( $concord_relation1->{relation} eq "HYPER" and $concord_relation2->{relation} eq "HYPO" ) {
                    $relations->{ $concord_relation1->{lemma} }->{ $concord_relation2->{multiword} }->{types}->{'hyper'}++;
                    $relations->{ $concord_relation1->{lemma} }->{ $concord_relation2->{multiword} }->{types}->{'hyper_hypo'}++;
                }

                elsif ( $concord_relation1->{relation} eq "HYPO" and $concord_relation2->{relation} eq "HYPO" ) {
                    $relations->{ $concord_relation1->{lemma} }->{ $concord_relation2->{multiword} }->{types}->{'cohypo'}++;
                }
                elsif ( $concord_relation1->{relation} eq "SYNO" and $concord_relation2->{relation} eq "SYNO" ) {
                    $relations->{ $concord_relation1->{lemma} }->{ $concord_relation2->{multiword} }->{types}->{'syno'}++;
                }
                else {
                    msg("unknown relation type: " . $concord_relation1->{relation} . '(' . $concord_relation1->{multiword} . ')' . '-' . $concord_relation2->{relation} . '(' . $concord_relation2->{multiword} . ')', $error);
                }
            }
            if ( not exists $saved_relations{ $concord_relation2->{lemma} . "\t" . $concord_relation1->{multiword} } ) {
                $saved_relations{ $concord_relation2->{lemma} . "\t" . $concord_relation1->{multiword} } = 1;

                $relations->{ $concord_relation2->{lemma} }->{ $concord_relation1->{multiword} }->{rules}->{ $concord_relation1->{rule} }++;

                if ( $concord_relation1->{relation} eq "HYPO" and $concord_relation2->{relation} eq "HYPER" ) {
                    $relations->{ $concord_relation2->{lemma} }->{ $concord_relation1->{multiword} }->{types}->{'hyper'}++;
                    $relations->{ $concord_relation2->{lemma} }->{ $concord_relation1->{multiword} }->{types}->{'hyper_hypo'}++;
                }
                elsif ( $concord_relation1->{relation} eq "HYPER" and $concord_relation2->{relation} eq "HYPO" ) {
                    $relations->{ $concord_relation2->{lemma} }->{ $concord_relation1->{multiword} }->{types}->{'hypo'}++;
                    $relations->{ $concord_relation2->{lemma} }->{ $concord_relation1->{multiword} }->{types}->{'hyper_hypo'}++;
                }

                elsif ( $concord_relation1->{relation} eq "HYPO" and $concord_relation2->{relation} eq "HYPO" ) {
                    $relations->{ $concord_relation2->{lemma} }->{ $concord_relation1->{multiword} }->{types}->{'cohypo'}++;
                }
                elsif ( $concord_relation1->{relation} eq "SYNO" and $concord_relation2->{relation} eq "SYNO" ) {
                    $relations->{ $concord_relation2->{lemma} }->{ $concord_relation1->{multiword} }->{types}->{'syno'}++;
                }
                else {
                    msg("unknown relation type: " .  $concord_relation1->{relation} . '(' .  $concord_relation1->{multiword} . ')' . '-'. $concord_relation2->{relation} . '(' . $concord_relation2->{multiword} . ')', $error);
                }
            }

            if ( not exists $saved_relations{ $concord_relation1->{multiword} . "\t" . $concord_relation2->{lemma} } ) {
                $saved_relations{ $concord_relation1->{multiword} . "\t" . $concord_relation2->{lemma} } = 1;

                $relations->{ $concord_relation1->{multiword} }->{ $concord_relation2->{lemma} }->{rules}->{ $concord_relation1->{rule} }++;

                if ( $concord_relation1->{relation} eq "HYPO" and $concord_relation2->{relation} eq "HYPER" ) {
                    $relations->{ $concord_relation1->{multiword} }->{ $concord_relation2->{lemma} }->{types}->{'hypo'}++;
                    $relations->{ $concord_relation1->{multiword} }->{ $concord_relation2->{lemma} }->{types}->{'hyper_hypo'}++;
                }
                elsif ( $concord_relation1->{relation} eq "HYPER" and $concord_relation2->{relation} eq "HYPO" ) {
                    $relations->{ $concord_relation1->{multiword} }->{ $concord_relation2->{lemma} }->{types}->{'hyper'}++;
                    $relations->{ $concord_relation1->{multiword} }->{ $concord_relation2->{lemma} }->{types}->{'hyper_hypo'}++;
                }

                elsif ( $concord_relation1->{relation} eq "HYPO" and $concord_relation2->{relation} eq "HYPO" ) {
                    $relations->{ $concord_relation1->{multiword} }->{ $concord_relation2->{lemma} }->{types}->{'cohypo'}++;
                }
                elsif ( $concord_relation1->{relation} eq "SYNO" and $concord_relation2->{relation} eq "SYNO" ) {
                    $relations->{ $concord_relation1->{multiword} }->{ $concord_relation2->{lemma} }->{types}->{'syno'}++;
                }
                else {
                    msg("unknown relation type: " . $concord_relation1->{relation} . '(' . $concord_relation1->{multiword} . ')' . '-' . $concord_relation2->{relation} . '(' . $concord_relation2->{multiword} . ')', $error);
                }
            }

            if ( not exists $saved_relations{ $concord_relation2->{multiword} . "\t" . $concord_relation1->{lemma} } ) {
                $saved_relations{ $concord_relation2->{multiword} . "\t" . $concord_relation1->{lemma} } = 1;

                $relations->{ $concord_relation2->{multiword} }->{ $concord_relation1->{lemma} }->{rules}->{ $concord_relation1->{rule} }++;

                if ( $concord_relation1->{relation} eq "HYPO" and $concord_relation2->{relation} eq "HYPER" ) {
                    $relations->{ $concord_relation2->{multiword} }->{ $concord_relation1->{lemma} }->{types}->{'hyper'}++;
                    $relations->{ $concord_relation2->{multiword} }->{ $concord_relation1->{lemma} }->{types}->{'hyper_hypo'}++;
                }
                elsif ( $concord_relation1->{relation} eq "HYPER" and $concord_relation2->{relation} eq "HYPO" ) {
                    $relations->{ $concord_relation2->{multiword} }->{ $concord_relation1->{lemma} }->{types}->{'hypo'}++;
                    $relations->{ $concord_relation2->{multiword} }->{ $concord_relation1->{lemma} }->{types}->{'hyper_hypo'}++;
                }

                elsif ( $concord_relation1->{relation} eq "HYPO" and $concord_relation2->{relation} eq "HYPO" ) {
                    $relations->{ $concord_relation2->{multiword} }->{ $concord_relation1->{lemma} }->{types}->{'cohypo'}++;
                }
                elsif ( $concord_relation1->{relation} eq "SYNO" and $concord_relation2->{relation} eq "SYNO" ) {
                    $relations->{ $concord_relation2->{multiword} }->{ $concord_relation1->{lemma} }->{types}->{'syno'}++;
                }
                else {
                    msg("unknown relation type: " . $concord_relation1->{relation} . '(' . $concord_relation1->{multiword} . ')' . '-' . $concord_relation2->{relation} .  '(' . $concord_relation2->{multiword} . ')', $error);
                }
            }

        }
    }
}
$concord_fh->close;

#----------------------------------------------------------------------
# save pairs and pairs voc
#----------------------------------------------------------------------
my $pairs_fh     = IO::File->new( $opts->{output_dir} . '/' . 'pairs.csv',     'w' );
my $pairs_voc_fh = IO::File->new( $opts->{output_dir} . '/' . 'pairs-voc.csv', 'w' );
binmode( $pairs_fh,     ':encoding(utf8)' );
binmode( $pairs_voc_fh, ':encoding(utf8)' );

print $pairs_fh
"form;related;syno;cohypo;hyper_hypo;hyper;hypo;sum;pattern1;pattern2;pattern3;pattern4;pattern5;pattern6;pattern7;pattern8;pattern9;pattern10;pattern11;pattern12;pattern13;pattern14;pattern15;pattern16;pattern17\n";
print $pairs_voc_fh
"form;related;syno;cohypo;hyper_hypo;hyper;hypo;sum;pattern1;pattern2;pattern3;pattern4;pattern5;pattern6;pattern7;pattern8;pattern9;pattern10;pattern11;pattern12;pattern13;pattern14;pattern15;pattern16;pattern17\n";

foreach my $vedette ( sort keys %$relations ) {
    foreach my $related ( sort keys %{ $relations->{$vedette} } ) {

        my @types = (0) x 5;    # initialize tab @types with 5 elements at '0' #TODO

        my $i = 0;
        foreach my $type ( 'syno', 'cohypo', 'hyper_hypo', 'hyper', 'hypo' ) {
            $types[$i] = $relations->{$vedette}->{$related}->{types}->{$type} if exists $relations->{$vedette}->{$related}->{types}->{$type};
            $i++;
        }

        my $extractions = 0;
        my @rules = (0) x ( 17 + 1 );    # initalize tab @rules with 18 elements at '0'
        foreach my $rule ( keys %{ $relations->{$vedette}->{$related}->{rules} } ) {
            $rules[$rule] = $relations->{$vedette}->{$related}->{rules}->{$rule};
            $extractions += $relations->{$vedette}->{$related}->{rules}->{$rule};
        }
        shift @rules;    # remove column 0;
        print $pairs_fh $vedette,     ';', $related . ';', join( ";", @types ), ';', $extractions, ';', join( ";", @rules ), "\n";
        print $pairs_voc_fh $vedette, ';', $related . ';', join( ";", @types ), ';', $extractions, ';', join( ";", @rules ), "\n"
          if exists $vocabulary{$vedette} and exists $vocabulary{$related};

    }
}
$pairs_fh->close;
$pairs_voc_fh->close;

#----------------------------------------------------------------------
#save lemma frequency
#----------------------------------------------------------------------
my $corpus_lemma_freq = {};
foreach my $form ( keys %$corpus_words_freq ) {
    my $lemma = _lemmatize( $dico, $corpus_words_freq, $form );
    $corpus_lemma_freq->{$lemma} += $corpus_words_freq->{$form};
}
my $corpus_freq_fh = IO::File->new( $opts->{output_dir} . '/' . 'corpus-freq.csv', 'w' );
binmode $corpus_freq_fh, ':encoding(utf8)';

foreach my $lemma ( sort { $corpus_lemma_freq->{$b} <=> $corpus_lemma_freq->{$a} } keys %$corpus_lemma_freq ) {
    print $corpus_freq_fh $lemma, ';', $corpus_lemma_freq->{$lemma}, "\n";
}

$corpus_freq_fh->close;

#----------------------------------------------------------------------
# save lemma concordances frequency
#----------------------------------------------------------------------

my $pattern_concord = 'concord_XXXXXXXXXXXXXXXX';
my $suffix_concord  = '_utf16le.txt';
my $fh_concord;
my $filename_concord;
( $fh_concord, $filename_concord ) = File::Temp::tempfile(
    $pattern_concord,
    DIR    => $config{corpora}->{temp_dir},
    SUFFIX => $suffix_concord
);
binmode $fh_concord, ':encoding(utf16le)';
print $fh_concord "\x{feff}";
map { $_ =~ s/[[\]{}]//g } @concord;
print $fh_concord @concord;
$fh_concord->close;

my $uniconcord = $unitex->corpus( 'filename' => $filename_concord );
$uniconcord->normalize;
$uniconcord->apply_graph_in_merge_mode;
$uniconcord->apply_graph_in_replace_mode;
$uniconcord->tokenize;
$uniconcord->apply_lexical_ressources;
my $concord_tokens_freq = $uniconcord->get_tokens_by_frequency();
$uniconcord->delete_all_files();

my $concord_lemma_freq = {};
foreach my $form ( keys %$concord_tokens_freq ) {
    my $lemma = _lemmatize( $dico, $corpus_words_freq, $form );
    $concord_lemma_freq->{$lemma} += $concord_tokens_freq->{$form};
}
my $conc_freq_fh = IO::File->new( $opts->{output_dir} . '/' . 'conc-freq.csv', 'w' );
binmode $conc_freq_fh, ':encoding(utf8)';

foreach my $lemma (
    sort { $concord_lemma_freq->{$b} <=> $concord_lemma_freq->{$a} }
    keys %$concord_lemma_freq
  )
{
    print $conc_freq_fh $lemma, ';', $concord_lemma_freq->{$lemma}, "\n";
}

$conc_freq_fh->close;

#======================================================================
# ROUTINE _lemmatize
# Get a list of words
# Returns a lemmatized list
#======================================================================
sub _lemmatize {
    my $dico      = shift;
    my $dico_freq = shift;
    my @tokens    = @_;
    my @lemmas    = ();

    foreach my $token (@tokens) {
        my @candidates = $dico->search( form => $token, return => 'lemma' );
        if ( @candidates == 0 ) {
            push @lemmas, $token;
        }
        elsif ( @candidates == 1 ) {
            push @lemmas, $candidates[0];
        }
        else {
            my $max_candidate_occur = 0;
            my $best_candidate      = undef;
            foreach my $candidate (@candidates) {
                if ( exists $dico_freq->{$candidate}
                    and $dico_freq->{$candidate} > $max_candidate_occur )
                {
                    $max_candidate_occur = $dico_freq->{$candidate};
                    $best_candidate      = $candidate;
                }
            }
            push @lemmas, $best_candidate;
        }

    }
    if ( not defined $lemmas[0] ) {
        $lemmas[0] = $tokens[0];
    }
    return wantarray ? @lemmas : "@lemmas";
}

#======================================================================
# ROUTINE _are_valid_opts
# Validate all the program arguments
#======================================================================
sub _are_valid_opts {
    my $opts   = shift;
    my $result = 1;

    # test if vocabulary file exists
    if ( not -e $opts->{vocabulary} ) {
        $result = 0;
        my $err_msg = "Invalid argument (vocabulary)\n'" . $opts->{vocabulary} . "' file does not exist";
        error( $err_msg, $error );
    }

    # test if corpora files exist
    foreach my $corpus_file ( @{ $opts->{corpora} } ) {
        if ( not -e $corpus_file ) {
            $result = 0;
            my $err_msg = "Invalid argument (corpus)\n" . "'" . $corpus_file . "' file does not exist";
            error( $err_msg, $error );
        }
    }
    debug( $result != 0 ? "args validation: PASS" : "args validation: FAILED", $debug );
    return $result;
}

#======================================================================
# ROUTINE _is_valid_unitex_installation
# Control if UnitexToolLogger is accessible and running
# TODO: to move in Lingua::Unitex
#======================================================================
sub _is_valid_unitex_installation {
    my $unitex_dir = shift;
    chop $unitex_dir if $unitex_dir =~ /[\/\\]$/;
    my $result = 1;

    # test if unitex dir exists
    if ( not -e $unitex_dir ) {
        $result = 0;
        my $err_msg = "Directory $unitex_dir does not exist";
        debug(
            $result != 0
            ? "unitex validation: PASS"
            : "unitex validation: FAILED", $debug
        );
        error( $err_msg, $error );
        return $result;
    }

    # test if UnitexToolLogger exists (OS dependant)
    my $unitex_exe = "UnitexToolLogger";
    $unitex_exe = "UnitexToolLogger.exe" if $os eq "Win";
    my $unitex_path = undef;

    if ( !-e "$unitex_dir/App/$unitex_exe" and !-e "$unitex_dir/$unitex_exe" ) {
        $result = 0;
        my $err_msg = "Impossible to find the $unitex_exe program in $unitex_dir";
        debug(
            $result != 0
            ? "unitex validation PASS"
            : "unitex validation FAILED", $debug
        );
        error( $err_msg, $error );
        return $result;
    }
    elsif ( -e "$unitex_dir/App/$unitex_exe" ) {
        $unitex_path = "$unitex_dir/App/$unitex_exe";
    }
    elsif ( -e "$unitex_dir/$unitex_exe" ) {
        $unitex_path = "$unitex_dir/$unitex_exe";
    }

    # test if UnitexToolLogger returns a 0 value
    run3( $unitex_path, \undef, \undef, \undef, { return_if_system_error => 1 } );
    if ( $? != 0 ) {
        $result = 0;
        my $err_msg = "$unitex_path returns the error code $?";
        debug(
            $result != 0
            ? "unitex validation PASS"
            : "unitex validation FAILED", $debug
        );
        error( $err_msg, $error );
        return $result;
    }

    debug( $result != 0 ? "unitex validation PASS" : "unitex validation FAILED", $debug );
    return $result;
}

sub trim {
    for ( my $i = 0 ; $i < @_ ; $i++ ) {
        $_[$i] =~ s/^\s+//;
        $_[$i] =~ s/\s+$//;
    }
}

__DATA__

=head1 NAME

patternsim - DESCRIPTION

=head1 SYNOPSIS

patternsim [options] [corpus_file(s) ...]

  Options:
    --vocabulary (-v)        input vocabulary file
    --output (-o)            output directory
    --unitex                 Unitex main directory

    --verbose                verbose mode
    --help                   brief help message
    --man                    full documentation

=head1 OPTIONS

=over 8

=item --vocabulary --vocab -v I<vocabulary_file>

Specify the UTF-8 input vocabulary file
(one word per line)

=item --unitex I<unitex_main_directory>

Specify the Unitex main directory
if you want to use your own Unitex installation
(overwite the B<patternsim> configuration file)

At first run, B<patternsim> will ask you if you want
to install the Unitex program automatically
or if you want to specify the location
of your Unitex main directory.

=item --workers -w I<number_of_workers>

Specify the number of parallel workers
Workers will extract in parallel semantic relations. 
A good number of workers will be the number of CPU cores minus 1.

=item --output -o I<output_directory>

Specify the output directory.

=item --verbose

Explains what is being done

=item --help -h

Prints a brief help message and exits.

=item --man

Prints the manual page and exits.

=item --verbose

Activates the verbose mode. Explains all the processes.
Outputs will be shown on stderr.


=back

=head1 DESCRIPTION

TODO

=cut
